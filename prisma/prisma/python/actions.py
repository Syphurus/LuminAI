# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class GeneratedImageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.GeneratedImage]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await GeneratedImage.prisma().query_raw(
            'SELECT * FROM GeneratedImage WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.GeneratedImage
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await GeneratedImage.prisma().query_first(
            'SELECT * FROM GeneratedImage WHERE userId = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GeneratedImageCreateInput,
        include: Optional[types.GeneratedImageInclude] = None
    ) -> _PrismaModelT:
        """Create a new GeneratedImage record.

        Parameters
        ----------
        data
            GeneratedImage record data
        include
            Specifies which relations should be loaded on the returned GeneratedImage model

        Returns
        -------
        prisma.models.GeneratedImage
            The created GeneratedImage record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a GeneratedImage record from just the required fields
        generatedimage = await GeneratedImage.prisma().create(
            data={
                # data to create a GeneratedImage record
                'userId': 'ggciceaie',
                'prompt': 'bbehjachib',
                'imageUrl': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GeneratedImageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple GeneratedImage records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of GeneratedImage record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await GeneratedImage.prisma().create_many(
            data=[
                {
                    # data to create a GeneratedImage record
                    'userId': 'dgiiaaijj',
                    'prompt': 'bfaiacjjfc',
                    'imageUrl': 'eigcfgbif',
                },
                {
                    # data to create a GeneratedImage record
                    'userId': 'bagcfbhiig',
                    'prompt': 'cghideieh',
                    'imageUrl': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GeneratedImageWhereUniqueInput,
        include: Optional[types.GeneratedImageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single GeneratedImage record.

        Parameters
        ----------
        where
            GeneratedImage filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedImage model

        Returns
        -------
        prisma.models.GeneratedImage
            The deleted GeneratedImage record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedimage = await GeneratedImage.prisma().delete(
            where={
                'id': 'idghgaicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GeneratedImageWhereUniqueInput,
        include: Optional[types.GeneratedImageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique GeneratedImage record.

        Parameters
        ----------
        where
            GeneratedImage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedImage model

        Returns
        -------
        prisma.models.GeneratedImage
            The found GeneratedImage record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedimage = await GeneratedImage.prisma().find_unique(
            where={
                'id': 'fjfddhigg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GeneratedImageWhereUniqueInput,
        include: Optional[types.GeneratedImageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique GeneratedImage record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            GeneratedImage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedImage model

        Returns
        -------
        prisma.models.GeneratedImage
            The found GeneratedImage record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedimage = await GeneratedImage.prisma().find_unique_or_raise(
            where={
                'id': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedImageWhereInput] = None,
        cursor: Optional[types.GeneratedImageWhereUniqueInput] = None,
        include: Optional[types.GeneratedImageInclude] = None,
        order: Optional[Union[types.GeneratedImageOrderByInput, List[types.GeneratedImageOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedImageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple GeneratedImage records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of GeneratedImage records returned
        skip
            Ignore the first N results
        where
            GeneratedImage filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedImage model
        order
            Order the returned GeneratedImage records by any field
        distinct
            Filter GeneratedImage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.GeneratedImage]
            The list of all GeneratedImage records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 GeneratedImage records
        generatedimages = await GeneratedImage.prisma().find_many(take=10)

        # find the first 5 GeneratedImage records ordered by the prompt field
        generatedimages = await GeneratedImage.prisma().find_many(
            take=5,
            order={
                'prompt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedImageWhereInput] = None,
        cursor: Optional[types.GeneratedImageWhereUniqueInput] = None,
        include: Optional[types.GeneratedImageInclude] = None,
        order: Optional[Union[types.GeneratedImageOrderByInput, List[types.GeneratedImageOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedImageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single GeneratedImage record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneratedImage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedImage model
        order
            Order the returned GeneratedImage records by any field
        distinct
            Filter GeneratedImage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneratedImage
            The first GeneratedImage record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneratedImage record ordered by the imageUrl field
        generatedimage = await GeneratedImage.prisma().find_first(
            skip=1,
            order={
                'imageUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedImageWhereInput] = None,
        cursor: Optional[types.GeneratedImageWhereUniqueInput] = None,
        include: Optional[types.GeneratedImageInclude] = None,
        order: Optional[Union[types.GeneratedImageOrderByInput, List[types.GeneratedImageOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedImageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single GeneratedImage record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneratedImage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedImage model
        order
            Order the returned GeneratedImage records by any field
        distinct
            Filter GeneratedImage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneratedImage
            The first GeneratedImage record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneratedImage record ordered by the createdAt field
        generatedimage = await GeneratedImage.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GeneratedImageUpdateInput,
        where: types.GeneratedImageWhereUniqueInput,
        include: Optional[types.GeneratedImageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single GeneratedImage record.

        Parameters
        ----------
        data
            GeneratedImage record data specifying what to update
        where
            GeneratedImage filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned GeneratedImage model

        Returns
        -------
        prisma.models.GeneratedImage
            The updated GeneratedImage record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        generatedimage = await GeneratedImage.prisma().update(
            where={
                'id': 'cbbbjbfcii',
            },
            data={
                # data to update the GeneratedImage record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GeneratedImageWhereUniqueInput,
        data: types.GeneratedImageUpsertInput,
        include: Optional[types.GeneratedImageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            GeneratedImage filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned GeneratedImage model

        Returns
        -------
        prisma.models.GeneratedImage
            The created or updated GeneratedImage record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedimage = await GeneratedImage.prisma().upsert(
            where={
                'id': 'bbejhfidcb',
            },
            data={
                'create': {
                    'id': 'bbejhfidcb',
                    'userId': 'bagcfbhiig',
                    'prompt': 'cghideieh',
                    'imageUrl': 'biabhbdai',
                },
                'update': {
                    'userId': 'bagcfbhiig',
                    'prompt': 'cghideieh',
                    'imageUrl': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GeneratedImageUpdateManyMutationInput,
        where: types.GeneratedImageWhereInput,
    ) -> int:
        """Update multiple GeneratedImage records

        Parameters
        ----------
        data
            GeneratedImage data to update the selected GeneratedImage records to
        where
            Filter to select the GeneratedImage records to update

        Returns
        -------
        int
            The total number of GeneratedImage records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all GeneratedImage records
        total = await GeneratedImage.prisma().update_many(
            data={
                'id': 'bgeecijdgg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedImageWhereInput] = None,
        cursor: Optional[types.GeneratedImageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of GeneratedImage records present in the database

        Parameters
        ----------
        select
            Select the GeneratedImage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneratedImage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneratedImageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneratedImage.prisma().count()

        # results: prisma.types.GeneratedImageCountAggregateOutput
        results = await GeneratedImage.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GeneratedImageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedImageWhereInput] = None,
        cursor: Optional[types.GeneratedImageWhereUniqueInput] = None,
    ) -> types.GeneratedImageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GeneratedImageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedImageWhereInput] = None,
        cursor: Optional[types.GeneratedImageWhereUniqueInput] = None,
    ) -> Union[int, types.GeneratedImageCountAggregateOutput]:
        """Count the number of GeneratedImage records present in the database

        Parameters
        ----------
        select
            Select the GeneratedImage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneratedImage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneratedImageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneratedImage.prisma().count()

        # results: prisma.types.GeneratedImageCountAggregateOutput
        results = await GeneratedImage.prisma().count(
            select={
                '_all': True,
                'prompt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GeneratedImageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GeneratedImageWhereInput] = None
    ) -> int:
        """Delete multiple GeneratedImage records.

        Parameters
        ----------
        where
            Optional GeneratedImage filter to find the records to be deleted

        Returns
        -------
        int
            The total number of GeneratedImage records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all GeneratedImage records
        total = await GeneratedImage.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GeneratedImageScalarFieldKeys'],
        *,
        where: Optional['types.GeneratedImageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GeneratedImageAvgAggregateInput'] = None,
        sum: Optional['types.GeneratedImageSumAggregateInput'] = None,
        min: Optional['types.GeneratedImageMinAggregateInput'] = None,
        max: Optional['types.GeneratedImageMaxAggregateInput'] = None,
        having: Optional['types.GeneratedImageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GeneratedImageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GeneratedImageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GeneratedImageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GeneratedImageGroupByOutput']:
        """Group GeneratedImage records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar GeneratedImage fields to group records by
        where
            GeneratedImage filter to select records
        take
            Limit the maximum number of GeneratedImage records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GeneratedImageGroupByOutput]
            A list of dictionaries representing the GeneratedImage record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group GeneratedImage records by imageUrl values
        # and count how many records are in each group
        results = await GeneratedImage.prisma().group_by(
            ['imageUrl'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GeneratedVideoActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.GeneratedVideo]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await GeneratedVideo.prisma().query_raw(
            'SELECT * FROM GeneratedVideo WHERE id = $1',
            'bdiicjafbj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.GeneratedVideo
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await GeneratedVideo.prisma().query_first(
            'SELECT * FROM GeneratedVideo WHERE userId = $1',
            'bgehebiafc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GeneratedVideoCreateInput,
        include: Optional[types.GeneratedVideoInclude] = None
    ) -> _PrismaModelT:
        """Create a new GeneratedVideo record.

        Parameters
        ----------
        data
            GeneratedVideo record data
        include
            Specifies which relations should be loaded on the returned GeneratedVideo model

        Returns
        -------
        prisma.models.GeneratedVideo
            The created GeneratedVideo record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a GeneratedVideo record from just the required fields
        generatedvideo = await GeneratedVideo.prisma().create(
            data={
                # data to create a GeneratedVideo record
                'userId': 'bghffegacj',
                'prompt': 'bhghchehcc',
                'videoUrl': 'dcgchcbbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GeneratedVideoCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple GeneratedVideo records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of GeneratedVideo record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await GeneratedVideo.prisma().create_many(
            data=[
                {
                    # data to create a GeneratedVideo record
                    'userId': 'bdedcabahc',
                    'prompt': 'ghfhiafcb',
                    'videoUrl': 'heejgedji',
                },
                {
                    # data to create a GeneratedVideo record
                    'userId': 'bjgjgibgbf',
                    'prompt': 'bbbgbhfjge',
                    'videoUrl': 'igbehcbab',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GeneratedVideoWhereUniqueInput,
        include: Optional[types.GeneratedVideoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single GeneratedVideo record.

        Parameters
        ----------
        where
            GeneratedVideo filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedVideo model

        Returns
        -------
        prisma.models.GeneratedVideo
            The deleted GeneratedVideo record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedvideo = await GeneratedVideo.prisma().delete(
            where={
                'id': 'bdadaadhag',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GeneratedVideoWhereUniqueInput,
        include: Optional[types.GeneratedVideoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique GeneratedVideo record.

        Parameters
        ----------
        where
            GeneratedVideo filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedVideo model

        Returns
        -------
        prisma.models.GeneratedVideo
            The found GeneratedVideo record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedvideo = await GeneratedVideo.prisma().find_unique(
            where={
                'id': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GeneratedVideoWhereUniqueInput,
        include: Optional[types.GeneratedVideoInclude] = None
    ) -> _PrismaModelT:
        """Find a unique GeneratedVideo record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            GeneratedVideo filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedVideo model

        Returns
        -------
        prisma.models.GeneratedVideo
            The found GeneratedVideo record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedvideo = await GeneratedVideo.prisma().find_unique_or_raise(
            where={
                'id': 'caaaedabfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedVideoWhereInput] = None,
        cursor: Optional[types.GeneratedVideoWhereUniqueInput] = None,
        include: Optional[types.GeneratedVideoInclude] = None,
        order: Optional[Union[types.GeneratedVideoOrderByInput, List[types.GeneratedVideoOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedVideoScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple GeneratedVideo records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of GeneratedVideo records returned
        skip
            Ignore the first N results
        where
            GeneratedVideo filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedVideo model
        order
            Order the returned GeneratedVideo records by any field
        distinct
            Filter GeneratedVideo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.GeneratedVideo]
            The list of all GeneratedVideo records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 GeneratedVideo records
        generatedvideos = await GeneratedVideo.prisma().find_many(take=10)

        # find the first 5 GeneratedVideo records ordered by the prompt field
        generatedvideos = await GeneratedVideo.prisma().find_many(
            take=5,
            order={
                'prompt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedVideoWhereInput] = None,
        cursor: Optional[types.GeneratedVideoWhereUniqueInput] = None,
        include: Optional[types.GeneratedVideoInclude] = None,
        order: Optional[Union[types.GeneratedVideoOrderByInput, List[types.GeneratedVideoOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedVideoScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single GeneratedVideo record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneratedVideo filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedVideo model
        order
            Order the returned GeneratedVideo records by any field
        distinct
            Filter GeneratedVideo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneratedVideo
            The first GeneratedVideo record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneratedVideo record ordered by the videoUrl field
        generatedvideo = await GeneratedVideo.prisma().find_first(
            skip=1,
            order={
                'videoUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedVideoWhereInput] = None,
        cursor: Optional[types.GeneratedVideoWhereUniqueInput] = None,
        include: Optional[types.GeneratedVideoInclude] = None,
        order: Optional[Union[types.GeneratedVideoOrderByInput, List[types.GeneratedVideoOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedVideoScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single GeneratedVideo record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneratedVideo filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedVideo model
        order
            Order the returned GeneratedVideo records by any field
        distinct
            Filter GeneratedVideo records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneratedVideo
            The first GeneratedVideo record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneratedVideo record ordered by the createdAt field
        generatedvideo = await GeneratedVideo.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GeneratedVideoUpdateInput,
        where: types.GeneratedVideoWhereUniqueInput,
        include: Optional[types.GeneratedVideoInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single GeneratedVideo record.

        Parameters
        ----------
        data
            GeneratedVideo record data specifying what to update
        where
            GeneratedVideo filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned GeneratedVideo model

        Returns
        -------
        prisma.models.GeneratedVideo
            The updated GeneratedVideo record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        generatedvideo = await GeneratedVideo.prisma().update(
            where={
                'id': 'bigibebcib',
            },
            data={
                # data to update the GeneratedVideo record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GeneratedVideoWhereUniqueInput,
        data: types.GeneratedVideoUpsertInput,
        include: Optional[types.GeneratedVideoInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            GeneratedVideo filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned GeneratedVideo model

        Returns
        -------
        prisma.models.GeneratedVideo
            The created or updated GeneratedVideo record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedvideo = await GeneratedVideo.prisma().upsert(
            where={
                'id': 'bigaiehgcc',
            },
            data={
                'create': {
                    'id': 'bigaiehgcc',
                    'userId': 'bjgjgibgbf',
                    'prompt': 'bbbgbhfjge',
                    'videoUrl': 'igbehcbab',
                },
                'update': {
                    'userId': 'bjgjgibgbf',
                    'prompt': 'bbbgbhfjge',
                    'videoUrl': 'igbehcbab',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GeneratedVideoUpdateManyMutationInput,
        where: types.GeneratedVideoWhereInput,
    ) -> int:
        """Update multiple GeneratedVideo records

        Parameters
        ----------
        data
            GeneratedVideo data to update the selected GeneratedVideo records to
        where
            Filter to select the GeneratedVideo records to update

        Returns
        -------
        int
            The total number of GeneratedVideo records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all GeneratedVideo records
        total = await GeneratedVideo.prisma().update_many(
            data={
                'id': 'beeifcbebf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedVideoWhereInput] = None,
        cursor: Optional[types.GeneratedVideoWhereUniqueInput] = None,
    ) -> int:
        """Count the number of GeneratedVideo records present in the database

        Parameters
        ----------
        select
            Select the GeneratedVideo fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneratedVideo filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneratedVideoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneratedVideo.prisma().count()

        # results: prisma.types.GeneratedVideoCountAggregateOutput
        results = await GeneratedVideo.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GeneratedVideoCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedVideoWhereInput] = None,
        cursor: Optional[types.GeneratedVideoWhereUniqueInput] = None,
    ) -> types.GeneratedVideoCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GeneratedVideoCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedVideoWhereInput] = None,
        cursor: Optional[types.GeneratedVideoWhereUniqueInput] = None,
    ) -> Union[int, types.GeneratedVideoCountAggregateOutput]:
        """Count the number of GeneratedVideo records present in the database

        Parameters
        ----------
        select
            Select the GeneratedVideo fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneratedVideo filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneratedVideoCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneratedVideo.prisma().count()

        # results: prisma.types.GeneratedVideoCountAggregateOutput
        results = await GeneratedVideo.prisma().count(
            select={
                '_all': True,
                'prompt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GeneratedVideoCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GeneratedVideoWhereInput] = None
    ) -> int:
        """Delete multiple GeneratedVideo records.

        Parameters
        ----------
        where
            Optional GeneratedVideo filter to find the records to be deleted

        Returns
        -------
        int
            The total number of GeneratedVideo records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all GeneratedVideo records
        total = await GeneratedVideo.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GeneratedVideoScalarFieldKeys'],
        *,
        where: Optional['types.GeneratedVideoWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GeneratedVideoAvgAggregateInput'] = None,
        sum: Optional['types.GeneratedVideoSumAggregateInput'] = None,
        min: Optional['types.GeneratedVideoMinAggregateInput'] = None,
        max: Optional['types.GeneratedVideoMaxAggregateInput'] = None,
        having: Optional['types.GeneratedVideoScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GeneratedVideoCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GeneratedVideoScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GeneratedVideoScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GeneratedVideoGroupByOutput']:
        """Group GeneratedVideo records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar GeneratedVideo fields to group records by
        where
            GeneratedVideo filter to select records
        take
            Limit the maximum number of GeneratedVideo records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GeneratedVideoGroupByOutput]
            A list of dictionaries representing the GeneratedVideo record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group GeneratedVideo records by videoUrl values
        # and count how many records are in each group
        results = await GeneratedVideo.prisma().group_by(
            ['videoUrl'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GeneratedSummaryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.GeneratedSummary]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await GeneratedSummary.prisma().query_raw(
            'SELECT * FROM GeneratedSummary WHERE id = $1',
            'bgcigfahea',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.GeneratedSummary
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await GeneratedSummary.prisma().query_first(
            'SELECT * FROM GeneratedSummary WHERE userId = $1',
            'bcejgaggif',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GeneratedSummaryCreateInput,
        include: Optional[types.GeneratedSummaryInclude] = None
    ) -> _PrismaModelT:
        """Create a new GeneratedSummary record.

        Parameters
        ----------
        data
            GeneratedSummary record data
        include
            Specifies which relations should be loaded on the returned GeneratedSummary model

        Returns
        -------
        prisma.models.GeneratedSummary
            The created GeneratedSummary record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a GeneratedSummary record from just the required fields
        generatedsummary = await GeneratedSummary.prisma().create(
            data={
                # data to create a GeneratedSummary record
                'userId': 'idfjadbcc',
                'prompt': 'hgdhbjhhj',
                'summary': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GeneratedSummaryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple GeneratedSummary records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of GeneratedSummary record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await GeneratedSummary.prisma().create_many(
            data=[
                {
                    # data to create a GeneratedSummary record
                    'userId': 'bhhfibbigf',
                    'prompt': 'ijdbeffgg',
                    'summary': 'jjfeafhfj',
                },
                {
                    # data to create a GeneratedSummary record
                    'userId': 'cbachdgfce',
                    'prompt': 'chbfcacbd',
                    'summary': 'efggddide',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GeneratedSummaryWhereUniqueInput,
        include: Optional[types.GeneratedSummaryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single GeneratedSummary record.

        Parameters
        ----------
        where
            GeneratedSummary filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedSummary model

        Returns
        -------
        prisma.models.GeneratedSummary
            The deleted GeneratedSummary record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedsummary = await GeneratedSummary.prisma().delete(
            where={
                'id': 'caficfigfb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GeneratedSummaryWhereUniqueInput,
        include: Optional[types.GeneratedSummaryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique GeneratedSummary record.

        Parameters
        ----------
        where
            GeneratedSummary filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedSummary model

        Returns
        -------
        prisma.models.GeneratedSummary
            The found GeneratedSummary record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedsummary = await GeneratedSummary.prisma().find_unique(
            where={
                'id': 'bfidgijfjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GeneratedSummaryWhereUniqueInput,
        include: Optional[types.GeneratedSummaryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique GeneratedSummary record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            GeneratedSummary filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedSummary model

        Returns
        -------
        prisma.models.GeneratedSummary
            The found GeneratedSummary record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedsummary = await GeneratedSummary.prisma().find_unique_or_raise(
            where={
                'id': 'ihieecagf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSummaryWhereInput] = None,
        cursor: Optional[types.GeneratedSummaryWhereUniqueInput] = None,
        include: Optional[types.GeneratedSummaryInclude] = None,
        order: Optional[Union[types.GeneratedSummaryOrderByInput, List[types.GeneratedSummaryOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedSummaryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple GeneratedSummary records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of GeneratedSummary records returned
        skip
            Ignore the first N results
        where
            GeneratedSummary filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedSummary model
        order
            Order the returned GeneratedSummary records by any field
        distinct
            Filter GeneratedSummary records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.GeneratedSummary]
            The list of all GeneratedSummary records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 GeneratedSummary records
        generatedsummarys = await GeneratedSummary.prisma().find_many(take=10)

        # find the first 5 GeneratedSummary records ordered by the prompt field
        generatedsummarys = await GeneratedSummary.prisma().find_many(
            take=5,
            order={
                'prompt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSummaryWhereInput] = None,
        cursor: Optional[types.GeneratedSummaryWhereUniqueInput] = None,
        include: Optional[types.GeneratedSummaryInclude] = None,
        order: Optional[Union[types.GeneratedSummaryOrderByInput, List[types.GeneratedSummaryOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedSummaryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single GeneratedSummary record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneratedSummary filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedSummary model
        order
            Order the returned GeneratedSummary records by any field
        distinct
            Filter GeneratedSummary records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneratedSummary
            The first GeneratedSummary record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneratedSummary record ordered by the summary field
        generatedsummary = await GeneratedSummary.prisma().find_first(
            skip=1,
            order={
                'summary': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSummaryWhereInput] = None,
        cursor: Optional[types.GeneratedSummaryWhereUniqueInput] = None,
        include: Optional[types.GeneratedSummaryInclude] = None,
        order: Optional[Union[types.GeneratedSummaryOrderByInput, List[types.GeneratedSummaryOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedSummaryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single GeneratedSummary record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneratedSummary filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedSummary model
        order
            Order the returned GeneratedSummary records by any field
        distinct
            Filter GeneratedSummary records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneratedSummary
            The first GeneratedSummary record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneratedSummary record ordered by the createdAt field
        generatedsummary = await GeneratedSummary.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GeneratedSummaryUpdateInput,
        where: types.GeneratedSummaryWhereUniqueInput,
        include: Optional[types.GeneratedSummaryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single GeneratedSummary record.

        Parameters
        ----------
        data
            GeneratedSummary record data specifying what to update
        where
            GeneratedSummary filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned GeneratedSummary model

        Returns
        -------
        prisma.models.GeneratedSummary
            The updated GeneratedSummary record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        generatedsummary = await GeneratedSummary.prisma().update(
            where={
                'id': 'bghfciaafe',
            },
            data={
                # data to update the GeneratedSummary record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GeneratedSummaryWhereUniqueInput,
        data: types.GeneratedSummaryUpsertInput,
        include: Optional[types.GeneratedSummaryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            GeneratedSummary filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned GeneratedSummary model

        Returns
        -------
        prisma.models.GeneratedSummary
            The created or updated GeneratedSummary record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedsummary = await GeneratedSummary.prisma().upsert(
            where={
                'id': 'bgchfhgceh',
            },
            data={
                'create': {
                    'id': 'bgchfhgceh',
                    'userId': 'cbachdgfce',
                    'prompt': 'chbfcacbd',
                    'summary': 'efggddide',
                },
                'update': {
                    'userId': 'cbachdgfce',
                    'prompt': 'chbfcacbd',
                    'summary': 'efggddide',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GeneratedSummaryUpdateManyMutationInput,
        where: types.GeneratedSummaryWhereInput,
    ) -> int:
        """Update multiple GeneratedSummary records

        Parameters
        ----------
        data
            GeneratedSummary data to update the selected GeneratedSummary records to
        where
            Filter to select the GeneratedSummary records to update

        Returns
        -------
        int
            The total number of GeneratedSummary records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all GeneratedSummary records
        total = await GeneratedSummary.prisma().update_many(
            data={
                'id': 'cafeiaccbc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSummaryWhereInput] = None,
        cursor: Optional[types.GeneratedSummaryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of GeneratedSummary records present in the database

        Parameters
        ----------
        select
            Select the GeneratedSummary fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneratedSummary filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneratedSummaryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneratedSummary.prisma().count()

        # results: prisma.types.GeneratedSummaryCountAggregateOutput
        results = await GeneratedSummary.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GeneratedSummaryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSummaryWhereInput] = None,
        cursor: Optional[types.GeneratedSummaryWhereUniqueInput] = None,
    ) -> types.GeneratedSummaryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GeneratedSummaryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSummaryWhereInput] = None,
        cursor: Optional[types.GeneratedSummaryWhereUniqueInput] = None,
    ) -> Union[int, types.GeneratedSummaryCountAggregateOutput]:
        """Count the number of GeneratedSummary records present in the database

        Parameters
        ----------
        select
            Select the GeneratedSummary fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneratedSummary filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneratedSummaryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneratedSummary.prisma().count()

        # results: prisma.types.GeneratedSummaryCountAggregateOutput
        results = await GeneratedSummary.prisma().count(
            select={
                '_all': True,
                'prompt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GeneratedSummaryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GeneratedSummaryWhereInput] = None
    ) -> int:
        """Delete multiple GeneratedSummary records.

        Parameters
        ----------
        where
            Optional GeneratedSummary filter to find the records to be deleted

        Returns
        -------
        int
            The total number of GeneratedSummary records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all GeneratedSummary records
        total = await GeneratedSummary.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GeneratedSummaryScalarFieldKeys'],
        *,
        where: Optional['types.GeneratedSummaryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GeneratedSummaryAvgAggregateInput'] = None,
        sum: Optional['types.GeneratedSummarySumAggregateInput'] = None,
        min: Optional['types.GeneratedSummaryMinAggregateInput'] = None,
        max: Optional['types.GeneratedSummaryMaxAggregateInput'] = None,
        having: Optional['types.GeneratedSummaryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GeneratedSummaryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GeneratedSummaryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GeneratedSummaryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GeneratedSummaryGroupByOutput']:
        """Group GeneratedSummary records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar GeneratedSummary fields to group records by
        where
            GeneratedSummary filter to select records
        take
            Limit the maximum number of GeneratedSummary records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GeneratedSummaryGroupByOutput]
            A list of dictionaries representing the GeneratedSummary record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group GeneratedSummary records by summary values
        # and count how many records are in each group
        results = await GeneratedSummary.prisma().group_by(
            ['summary'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GeneratedGhibliActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.GeneratedGhibli]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await GeneratedGhibli.prisma().query_raw(
            'SELECT * FROM GeneratedGhibli WHERE id = $1',
            'gaddfhfh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.GeneratedGhibli
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await GeneratedGhibli.prisma().query_first(
            'SELECT * FROM GeneratedGhibli WHERE userId = $1',
            'gieegcbeg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GeneratedGhibliCreateInput,
        include: Optional[types.GeneratedGhibliInclude] = None
    ) -> _PrismaModelT:
        """Create a new GeneratedGhibli record.

        Parameters
        ----------
        data
            GeneratedGhibli record data
        include
            Specifies which relations should be loaded on the returned GeneratedGhibli model

        Returns
        -------
        prisma.models.GeneratedGhibli
            The created GeneratedGhibli record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a GeneratedGhibli record from just the required fields
        generatedghibli = await GeneratedGhibli.prisma().create(
            data={
                # data to create a GeneratedGhibli record
                'userId': 'bgcffadich',
                'prompt': 'fcbichhci',
                'imageUrl': 'bcggadccgf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GeneratedGhibliCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple GeneratedGhibli records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of GeneratedGhibli record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await GeneratedGhibli.prisma().create_many(
            data=[
                {
                    # data to create a GeneratedGhibli record
                    'userId': 'jdcfdcgc',
                    'prompt': 'cafdaehjid',
                    'imageUrl': 'gifdddbia',
                },
                {
                    # data to create a GeneratedGhibli record
                    'userId': 'bchehecef',
                    'prompt': 'jeijcbhfe',
                    'imageUrl': 'bjgejjabff',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GeneratedGhibliWhereUniqueInput,
        include: Optional[types.GeneratedGhibliInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single GeneratedGhibli record.

        Parameters
        ----------
        where
            GeneratedGhibli filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedGhibli model

        Returns
        -------
        prisma.models.GeneratedGhibli
            The deleted GeneratedGhibli record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedghibli = await GeneratedGhibli.prisma().delete(
            where={
                'id': 'bcciijbibg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GeneratedGhibliWhereUniqueInput,
        include: Optional[types.GeneratedGhibliInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique GeneratedGhibli record.

        Parameters
        ----------
        where
            GeneratedGhibli filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedGhibli model

        Returns
        -------
        prisma.models.GeneratedGhibli
            The found GeneratedGhibli record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedghibli = await GeneratedGhibli.prisma().find_unique(
            where={
                'id': 'cffcachfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GeneratedGhibliWhereUniqueInput,
        include: Optional[types.GeneratedGhibliInclude] = None
    ) -> _PrismaModelT:
        """Find a unique GeneratedGhibli record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            GeneratedGhibli filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedGhibli model

        Returns
        -------
        prisma.models.GeneratedGhibli
            The found GeneratedGhibli record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedghibli = await GeneratedGhibli.prisma().find_unique_or_raise(
            where={
                'id': 'bccdfhdigc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedGhibliWhereInput] = None,
        cursor: Optional[types.GeneratedGhibliWhereUniqueInput] = None,
        include: Optional[types.GeneratedGhibliInclude] = None,
        order: Optional[Union[types.GeneratedGhibliOrderByInput, List[types.GeneratedGhibliOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedGhibliScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple GeneratedGhibli records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of GeneratedGhibli records returned
        skip
            Ignore the first N results
        where
            GeneratedGhibli filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedGhibli model
        order
            Order the returned GeneratedGhibli records by any field
        distinct
            Filter GeneratedGhibli records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.GeneratedGhibli]
            The list of all GeneratedGhibli records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 GeneratedGhibli records
        generatedghiblis = await GeneratedGhibli.prisma().find_many(take=10)

        # find the first 5 GeneratedGhibli records ordered by the prompt field
        generatedghiblis = await GeneratedGhibli.prisma().find_many(
            take=5,
            order={
                'prompt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedGhibliWhereInput] = None,
        cursor: Optional[types.GeneratedGhibliWhereUniqueInput] = None,
        include: Optional[types.GeneratedGhibliInclude] = None,
        order: Optional[Union[types.GeneratedGhibliOrderByInput, List[types.GeneratedGhibliOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedGhibliScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single GeneratedGhibli record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneratedGhibli filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedGhibli model
        order
            Order the returned GeneratedGhibli records by any field
        distinct
            Filter GeneratedGhibli records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneratedGhibli
            The first GeneratedGhibli record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneratedGhibli record ordered by the imageUrl field
        generatedghibli = await GeneratedGhibli.prisma().find_first(
            skip=1,
            order={
                'imageUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedGhibliWhereInput] = None,
        cursor: Optional[types.GeneratedGhibliWhereUniqueInput] = None,
        include: Optional[types.GeneratedGhibliInclude] = None,
        order: Optional[Union[types.GeneratedGhibliOrderByInput, List[types.GeneratedGhibliOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedGhibliScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single GeneratedGhibli record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneratedGhibli filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedGhibli model
        order
            Order the returned GeneratedGhibli records by any field
        distinct
            Filter GeneratedGhibli records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneratedGhibli
            The first GeneratedGhibli record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneratedGhibli record ordered by the createdAt field
        generatedghibli = await GeneratedGhibli.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GeneratedGhibliUpdateInput,
        where: types.GeneratedGhibliWhereUniqueInput,
        include: Optional[types.GeneratedGhibliInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single GeneratedGhibli record.

        Parameters
        ----------
        data
            GeneratedGhibli record data specifying what to update
        where
            GeneratedGhibli filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned GeneratedGhibli model

        Returns
        -------
        prisma.models.GeneratedGhibli
            The updated GeneratedGhibli record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        generatedghibli = await GeneratedGhibli.prisma().update(
            where={
                'id': 'febcgjbfj',
            },
            data={
                # data to update the GeneratedGhibli record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GeneratedGhibliWhereUniqueInput,
        data: types.GeneratedGhibliUpsertInput,
        include: Optional[types.GeneratedGhibliInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            GeneratedGhibli filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned GeneratedGhibli model

        Returns
        -------
        prisma.models.GeneratedGhibli
            The created or updated GeneratedGhibli record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedghibli = await GeneratedGhibli.prisma().upsert(
            where={
                'id': 'bageiegghg',
            },
            data={
                'create': {
                    'id': 'bageiegghg',
                    'userId': 'bchehecef',
                    'prompt': 'jeijcbhfe',
                    'imageUrl': 'bjgejjabff',
                },
                'update': {
                    'userId': 'bchehecef',
                    'prompt': 'jeijcbhfe',
                    'imageUrl': 'bjgejjabff',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GeneratedGhibliUpdateManyMutationInput,
        where: types.GeneratedGhibliWhereInput,
    ) -> int:
        """Update multiple GeneratedGhibli records

        Parameters
        ----------
        data
            GeneratedGhibli data to update the selected GeneratedGhibli records to
        where
            Filter to select the GeneratedGhibli records to update

        Returns
        -------
        int
            The total number of GeneratedGhibli records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all GeneratedGhibli records
        total = await GeneratedGhibli.prisma().update_many(
            data={
                'id': 'faidicegb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedGhibliWhereInput] = None,
        cursor: Optional[types.GeneratedGhibliWhereUniqueInput] = None,
    ) -> int:
        """Count the number of GeneratedGhibli records present in the database

        Parameters
        ----------
        select
            Select the GeneratedGhibli fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneratedGhibli filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneratedGhibliCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneratedGhibli.prisma().count()

        # results: prisma.types.GeneratedGhibliCountAggregateOutput
        results = await GeneratedGhibli.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GeneratedGhibliCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedGhibliWhereInput] = None,
        cursor: Optional[types.GeneratedGhibliWhereUniqueInput] = None,
    ) -> types.GeneratedGhibliCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GeneratedGhibliCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedGhibliWhereInput] = None,
        cursor: Optional[types.GeneratedGhibliWhereUniqueInput] = None,
    ) -> Union[int, types.GeneratedGhibliCountAggregateOutput]:
        """Count the number of GeneratedGhibli records present in the database

        Parameters
        ----------
        select
            Select the GeneratedGhibli fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneratedGhibli filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneratedGhibliCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneratedGhibli.prisma().count()

        # results: prisma.types.GeneratedGhibliCountAggregateOutput
        results = await GeneratedGhibli.prisma().count(
            select={
                '_all': True,
                'prompt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GeneratedGhibliCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GeneratedGhibliWhereInput] = None
    ) -> int:
        """Delete multiple GeneratedGhibli records.

        Parameters
        ----------
        where
            Optional GeneratedGhibli filter to find the records to be deleted

        Returns
        -------
        int
            The total number of GeneratedGhibli records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all GeneratedGhibli records
        total = await GeneratedGhibli.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GeneratedGhibliScalarFieldKeys'],
        *,
        where: Optional['types.GeneratedGhibliWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GeneratedGhibliAvgAggregateInput'] = None,
        sum: Optional['types.GeneratedGhibliSumAggregateInput'] = None,
        min: Optional['types.GeneratedGhibliMinAggregateInput'] = None,
        max: Optional['types.GeneratedGhibliMaxAggregateInput'] = None,
        having: Optional['types.GeneratedGhibliScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GeneratedGhibliCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GeneratedGhibliScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GeneratedGhibliScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GeneratedGhibliGroupByOutput']:
        """Group GeneratedGhibli records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar GeneratedGhibli fields to group records by
        where
            GeneratedGhibli filter to select records
        take
            Limit the maximum number of GeneratedGhibli records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GeneratedGhibliGroupByOutput]
            A list of dictionaries representing the GeneratedGhibli record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group GeneratedGhibli records by imageUrl values
        # and count how many records are in each group
        results = await GeneratedGhibli.prisma().group_by(
            ['imageUrl'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GeneratedSVGActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.GeneratedSVG]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await GeneratedSVG.prisma().query_raw(
            'SELECT * FROM GeneratedSVG WHERE id = $1',
            'bacecgfhbe',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.GeneratedSVG
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await GeneratedSVG.prisma().query_first(
            'SELECT * FROM GeneratedSVG WHERE userId = $1',
            'ihcahiead',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GeneratedSVGCreateInput,
        include: Optional[types.GeneratedSVGInclude] = None
    ) -> _PrismaModelT:
        """Create a new GeneratedSVG record.

        Parameters
        ----------
        data
            GeneratedSVG record data
        include
            Specifies which relations should be loaded on the returned GeneratedSVG model

        Returns
        -------
        prisma.models.GeneratedSVG
            The created GeneratedSVG record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a GeneratedSVG record from just the required fields
        generatedsvg = await GeneratedSVG.prisma().create(
            data={
                # data to create a GeneratedSVG record
                'userId': 'biheheiajg',
                'prompt': 'jbgijghgb',
                'svg': 'hgjcghfbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GeneratedSVGCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple GeneratedSVG records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of GeneratedSVG record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await GeneratedSVG.prisma().create_many(
            data=[
                {
                    # data to create a GeneratedSVG record
                    'userId': 'icadbcehj',
                    'prompt': 'jchciaee',
                    'svg': 'deeificjd',
                },
                {
                    # data to create a GeneratedSVG record
                    'userId': 'bbcbhebbda',
                    'prompt': 'bejfijgcfb',
                    'svg': 'caifcbgii',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GeneratedSVGWhereUniqueInput,
        include: Optional[types.GeneratedSVGInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single GeneratedSVG record.

        Parameters
        ----------
        where
            GeneratedSVG filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedSVG model

        Returns
        -------
        prisma.models.GeneratedSVG
            The deleted GeneratedSVG record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedsvg = await GeneratedSVG.prisma().delete(
            where={
                'id': 'igaibbfgj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GeneratedSVGWhereUniqueInput,
        include: Optional[types.GeneratedSVGInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique GeneratedSVG record.

        Parameters
        ----------
        where
            GeneratedSVG filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedSVG model

        Returns
        -------
        prisma.models.GeneratedSVG
            The found GeneratedSVG record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedsvg = await GeneratedSVG.prisma().find_unique(
            where={
                'id': 'bggajdcbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GeneratedSVGWhereUniqueInput,
        include: Optional[types.GeneratedSVGInclude] = None
    ) -> _PrismaModelT:
        """Find a unique GeneratedSVG record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            GeneratedSVG filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GeneratedSVG model

        Returns
        -------
        prisma.models.GeneratedSVG
            The found GeneratedSVG record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedsvg = await GeneratedSVG.prisma().find_unique_or_raise(
            where={
                'id': 'fcfhgbjed',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSVGWhereInput] = None,
        cursor: Optional[types.GeneratedSVGWhereUniqueInput] = None,
        include: Optional[types.GeneratedSVGInclude] = None,
        order: Optional[Union[types.GeneratedSVGOrderByInput, List[types.GeneratedSVGOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedSVGScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple GeneratedSVG records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of GeneratedSVG records returned
        skip
            Ignore the first N results
        where
            GeneratedSVG filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedSVG model
        order
            Order the returned GeneratedSVG records by any field
        distinct
            Filter GeneratedSVG records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.GeneratedSVG]
            The list of all GeneratedSVG records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 GeneratedSVG records
        generatedsvgs = await GeneratedSVG.prisma().find_many(take=10)

        # find the first 5 GeneratedSVG records ordered by the prompt field
        generatedsvgs = await GeneratedSVG.prisma().find_many(
            take=5,
            order={
                'prompt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSVGWhereInput] = None,
        cursor: Optional[types.GeneratedSVGWhereUniqueInput] = None,
        include: Optional[types.GeneratedSVGInclude] = None,
        order: Optional[Union[types.GeneratedSVGOrderByInput, List[types.GeneratedSVGOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedSVGScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single GeneratedSVG record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneratedSVG filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedSVG model
        order
            Order the returned GeneratedSVG records by any field
        distinct
            Filter GeneratedSVG records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneratedSVG
            The first GeneratedSVG record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneratedSVG record ordered by the svg field
        generatedsvg = await GeneratedSVG.prisma().find_first(
            skip=1,
            order={
                'svg': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSVGWhereInput] = None,
        cursor: Optional[types.GeneratedSVGWhereUniqueInput] = None,
        include: Optional[types.GeneratedSVGInclude] = None,
        order: Optional[Union[types.GeneratedSVGOrderByInput, List[types.GeneratedSVGOrderByInput]]] = None,
        distinct: Optional[List[types.GeneratedSVGScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single GeneratedSVG record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GeneratedSVG filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GeneratedSVG model
        order
            Order the returned GeneratedSVG records by any field
        distinct
            Filter GeneratedSVG records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GeneratedSVG
            The first GeneratedSVG record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GeneratedSVG record ordered by the createdAt field
        generatedsvg = await GeneratedSVG.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GeneratedSVGUpdateInput,
        where: types.GeneratedSVGWhereUniqueInput,
        include: Optional[types.GeneratedSVGInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single GeneratedSVG record.

        Parameters
        ----------
        data
            GeneratedSVG record data specifying what to update
        where
            GeneratedSVG filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned GeneratedSVG model

        Returns
        -------
        prisma.models.GeneratedSVG
            The updated GeneratedSVG record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        generatedsvg = await GeneratedSVG.prisma().update(
            where={
                'id': 'hdgcajhjg',
            },
            data={
                # data to update the GeneratedSVG record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GeneratedSVGWhereUniqueInput,
        data: types.GeneratedSVGUpsertInput,
        include: Optional[types.GeneratedSVGInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            GeneratedSVG filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned GeneratedSVG model

        Returns
        -------
        prisma.models.GeneratedSVG
            The created or updated GeneratedSVG record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        generatedsvg = await GeneratedSVG.prisma().upsert(
            where={
                'id': 'ejdjahicb',
            },
            data={
                'create': {
                    'id': 'ejdjahicb',
                    'userId': 'bbcbhebbda',
                    'prompt': 'bejfijgcfb',
                    'svg': 'caifcbgii',
                },
                'update': {
                    'userId': 'bbcbhebbda',
                    'prompt': 'bejfijgcfb',
                    'svg': 'caifcbgii',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GeneratedSVGUpdateManyMutationInput,
        where: types.GeneratedSVGWhereInput,
    ) -> int:
        """Update multiple GeneratedSVG records

        Parameters
        ----------
        data
            GeneratedSVG data to update the selected GeneratedSVG records to
        where
            Filter to select the GeneratedSVG records to update

        Returns
        -------
        int
            The total number of GeneratedSVG records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all GeneratedSVG records
        total = await GeneratedSVG.prisma().update_many(
            data={
                'id': 'gdjgigfgc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSVGWhereInput] = None,
        cursor: Optional[types.GeneratedSVGWhereUniqueInput] = None,
    ) -> int:
        """Count the number of GeneratedSVG records present in the database

        Parameters
        ----------
        select
            Select the GeneratedSVG fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneratedSVG filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneratedSVGCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneratedSVG.prisma().count()

        # results: prisma.types.GeneratedSVGCountAggregateOutput
        results = await GeneratedSVG.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GeneratedSVGCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSVGWhereInput] = None,
        cursor: Optional[types.GeneratedSVGWhereUniqueInput] = None,
    ) -> types.GeneratedSVGCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GeneratedSVGCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GeneratedSVGWhereInput] = None,
        cursor: Optional[types.GeneratedSVGWhereUniqueInput] = None,
    ) -> Union[int, types.GeneratedSVGCountAggregateOutput]:
        """Count the number of GeneratedSVG records present in the database

        Parameters
        ----------
        select
            Select the GeneratedSVG fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GeneratedSVG filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GeneratedSVGCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GeneratedSVG.prisma().count()

        # results: prisma.types.GeneratedSVGCountAggregateOutput
        results = await GeneratedSVG.prisma().count(
            select={
                '_all': True,
                'prompt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GeneratedSVGCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GeneratedSVGWhereInput] = None
    ) -> int:
        """Delete multiple GeneratedSVG records.

        Parameters
        ----------
        where
            Optional GeneratedSVG filter to find the records to be deleted

        Returns
        -------
        int
            The total number of GeneratedSVG records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all GeneratedSVG records
        total = await GeneratedSVG.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GeneratedSVGScalarFieldKeys'],
        *,
        where: Optional['types.GeneratedSVGWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GeneratedSVGAvgAggregateInput'] = None,
        sum: Optional['types.GeneratedSVGSumAggregateInput'] = None,
        min: Optional['types.GeneratedSVGMinAggregateInput'] = None,
        max: Optional['types.GeneratedSVGMaxAggregateInput'] = None,
        having: Optional['types.GeneratedSVGScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GeneratedSVGCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GeneratedSVGScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GeneratedSVGScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GeneratedSVGGroupByOutput']:
        """Group GeneratedSVG records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar GeneratedSVG fields to group records by
        where
            GeneratedSVG filter to select records
        take
            Limit the maximum number of GeneratedSVG records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GeneratedSVGGroupByOutput]
            A list of dictionaries representing the GeneratedSVG record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group GeneratedSVG records by svg values
        # and count how many records are in each group
        results = await GeneratedSVG.prisma().group_by(
            ['svg'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models